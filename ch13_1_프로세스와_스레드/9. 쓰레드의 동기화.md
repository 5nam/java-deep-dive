## 쓰레드의 동기화
- 멀티쓰레드 프로세스
  - 여러 쓰레드가 같은 프로세스 내의 자원을 공유해서 작업
  - 서로의 작업에 영향을 주게 됨
  - ThreadA가 작업하던 도중 ThreadB에게 제어권이 넘어갔을 때, ThreadA가 작업하던 공유데이터를 ThreadB가 임의로 변경 - ThreadA가 다시 제어권을 받아서 나머지 작업 수행할 때 의도와 다른 결과 없을 수 있음
- 그래서 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요
  - 그렇게 도입된 개념이 바로 '임계영역(cirtical section)'과 '잠금(락, lock)'이다.
- 공유 데이터를 사용하는 코드 영역을 임계 영역으로 정해놓고, 공유 데이터가 가지고 있는 lock을 획든한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 하는 것
- 해당 쓰레드가 임계 영역 내의 모든 코드를 다 수행했다면 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득해서 임계 영역의 코드를 수행할 수 있음
- 이렇게 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하게 막는 것을 '쓰레드 동기화(synchronization)'라고 한다.

### synchronized를 이용한 동기화
- 가장 간단한 동기화 방법 `synchronized` 키워드 이용 방법
```java
// 1. 메서드 전체를 임계 영역으로 지정
public synchronized void calcSum() {
    // 임계 영역
}
// 2. 특정한 영역을 임계 영역으로 지정 : 메서 내의 코드 일부를 블럭{} 으로 감싸고 앞에 키워드 붙이는 것
synchronized(객체의 참조변수) {
    // 임계 영역    
}
```
1. 쓰레드는 synchronized 메서드가 호출된 시점부터 해당 메서드가 포함된 객체의 lock 을 얻어 작업을 수행하다가 메서드가 종료되면 lock 을 반환
2. 참조변수는 락을 걸고자하는 객체를 참조하는 것이어야 한다. 이 블럭 영역 안으로 들어가면서 쓰레드는 지정된 객체의 lock 을 얻고, 이 블럭을 벗어나면 반납한다.

- 두 방법 모두 lock 의 획득과 반납이 모두 자동적으로 이루어진다. 임계영역만 설정해주면 되는 것
- 임계영역을 최소화해서 보다 효율적인 프로그램이 되도록 해야 함

### wait() 와 notify()
- 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지 않도록 하는 것 중요
  예) 계좌에 출금할 돈이 부족하여 한 쓰레드가 락을 보유한 채로 돈이 입금될 때까지 기다리는 상황
- 이런 상황을 개선하기 위해 고안된 것 wait(), notify()
  - 동기화된 임계 영역의 코드를 수행하다 작업을 더 진행할 상황이 아니면, wait()를 호출하여 쓰레드가 락을 반납하고 대기
  - 다른 쓰레드는 락을 얻어 해당 객체에 대한 작업 수행
  - 나중에 다시 작업을 재개할 상황이 되면 notify()를 호출하여 다시 락을 얻어 작업 진행
- 여기서 차이가 있다면, 오래 기다린 쓰레드가 락을 얻는다는 보장이 없다는 것
  - wait() 호출 : 실행 중이던 쓰레드 해당 객체의 대기실(waiting pool)에서 통지를 기다림
  - notify() 호출 : 해당 객체의 대기실에 있던 모든 쓰레드 중 임의의 쓰레드만 통지 받음
  - notifyAll() 호출 : 대기 중인 모든 쓰레드에게 통보를 하지만, 그래도 락을 얻을 수 있는 것은 하나의 쓰레드. waiting pool에 대기 중인 쓰레드만 해당
```
wait(), notify(), notifyAll()
- Object에 정의됨
- 동기화 블록 내에서만 사용 가능
- 보다 효율적인 동기화를 가능하게 함
```

ThreadWaitEx1 예제
- 여기서 두 가지 종류의 예외가 발생
1. ConcurrentModificationException
   - 요리사(Cook) 쓰레드가 테이블에 음식을 놓는 도중에 손님(Customer) 쓰레드가 음식을 가져가려했기 때문에 발생
2. IndexOutOfBoundsException
   - 다른 손님 쓰레드가 먼저 음식을 낚아채버려서 있지도 않는 음식을 가져가는 도중에 다른 손님 쓰레드가 먼저 음식을 낚아채버려서 있지는 않는 음식을 테이블에서 제거하려고 했기 때문에 발생

이런 예외가 발생하는 이유
- 여러 쓰레드가 테이블을 공유하는데 동기화하지 않아서

ThreadWaitEx3 예제
- wait() 와 notify() 를 추가했다
- 테이블에 음식이 없을 때뿐만 아니라 원하는 음식이 없을 때도 손님이 기다리도록 바꿈
- 여기에도 문제 존재
  - 테이블 객체의 waiting pool에 요리사 쓰레드와 손님 쓰레드가 같이 대기한다는 것
  - notify()가 호출되었을 때 요리사/손님 중 누구한테 통지할지 알 수 없다.
  - 테이블의 음식이 줄어서 notify() 호출할 때는 요리사 쓰레드가 통지를 받아야 하는데, 만약 손님이 받으면 lock 을 얻어도 다시 waiting pool에 들어가게 됨

#### 기아 현상과 경쟁 상태
- 최악의 경우 요리사 쓰레드는 계속 통지 받지 못하고 계속 기다림
  - 이런 현상을 기아현상(starvation)이라고 함
  - 이 현상을 막으려면 notify() 대신 notifyAll()을 사용
  - 모든 쓰레드에 통지하면 손님 쓰레드는 다시 waiting pool에 들어가도 결국 lock을 얻어서 작업 진행이 가능하므로
- notifyAll() 로 기아현상은 막았지만, 손님 쓰레드까지 통지를 받아서 불필요하게 요리사 쓰레드와 lock을 얻기 위한 경쟁을 함
  - 여러 쓰레드가 lock을 얻기 위해 경쟁하는 것을 경쟁 상태(race condition)이라고 함
  - 이를 개선하기 위해서는 요리사 쓰레드와 손님 쓰레드를 구별해서 통지하는 것이 필요

그래서 Lock 과 Condition 이 등장함!
